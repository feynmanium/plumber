// Package main implements pipes for a stream of *semver.Version
package main

import (
	"fmt"

	"github.com/mh-cbon/plumber"
	"github.com/mh-cbon/semver"
)

// This file was automatically generated by
// github.com/mh-cbon/plumber
// To not edit.


// VersionPipeWriter receives *semver.Version
type VersionPipeWriter interface {
	plumber.Flusher
	plumber.Sinker
	Write(*semver.Version) error
}

// VersionStream receives *semver.Version, writes it to the connected Pipes.
type VersionStream struct {
	Streams []VersionPipeWriter
}

// Pipe connects a Pipe, returns the connected Pipe left-end.
func (p *VersionStream) Pipe(s plumber.Piper) plumber.Piper {
	p.Sink(s)
	return s
}

// Sink connects an ending Piper.
func (p *VersionStream) Sink(s plumber.Flusher) {
	x, ok := s.(VersionPipeWriter)
	if !ok {
		panic(
			fmt.Errorf("Cannot Pipe a %T on %T", s, p),
		)
	}
	p.Streams = append(p.Streams, x)
}

// Unpipe disconnect a connected Pipe.
func (p *VersionStream) Unpipe(s plumber.Flusher) {
	// todo: add sync
	x, ok := s.(VersionPipeWriter)
	if !ok {
		panic(
			fmt.Errorf("Cannot Pipe a %T on %T", s, p),
		)
	}
	i := -1
	for e, pp := range p.Streams {
		if pp == x {
			i = e
			break
		}
	}
	if i > -1 {
		p.Streams = append(p.Streams[:i], p.Streams[i+1:]...)
	}
}

// Flush flushes the connected Pipes.
func (p *VersionStream) Flush() error {
	for _, pp := range p.Streams {
		if err := pp.Flush(); err != nil {
			return err
		}
	}
	return nil
}

// Write a *semver.Version on the connected Pipes.
func (p *VersionStream) Write(d *semver.Version) error {
	for _, pp := range p.Streams {
		if err := pp.Write(d); err != nil {
			return err
		}
	}
	return nil
}
