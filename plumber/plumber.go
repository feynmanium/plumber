package main

import (
	"flag"
	"fmt"
	"html/template"
	"os"
	"strings"
)

var version = "0.0.0"

func main() {
	var help bool
	var h bool
	var ver bool
	var v bool
	flag.BoolVar(&help, "help", false, "Show help.")
	flag.BoolVar(&h, "h", false, "Show help.")
	flag.BoolVar(&ver, "version", false, "Show version.")
	flag.BoolVar(&v, "v", false, "Show version.")
	flag.Parse()

	if ver || v {
		showVer()
		return
	}
	if help || h {
		showHelp()
		return
	}

	if flag.NArg() < 3 {
		panic("wrong usage")
	}
	args := flag.Args()

	dst := os.Stdout
	out := args[0]
	if args[0] != "-" {
		var err error
		dst, err = os.Create(out)
		if err != nil {
			panic(err)
		}
	}
	pkg := args[1]
	fmt.Fprintf(dst, "// Package %v implements pipes for a stream of %v\n", pkg, strings.Join(args[2:], " "))
	fmt.Fprintf(dst, "package %v\n", pkg)
	fmt.Fprint(dst, `

// This file was automatically generated by
// github.com/mh-cbon/plumber
// To not edit.

`)
	for _, arg := range args[2:] {
		FQType := arg
		Name := FQType
		if strings.Index(Name, ".") > -1 {
			Name = strings.Split(Name, ".")[1]
		} else if Name[:2] == "[]" {
			Name = strings.Title(Name[2:])
		}
		data := map[string]string{
			"FQType": FQType,
			"Name":   Name,
		}
		t, err := template.New("").Parse(pipeTemplate)
		if err != nil {
			panic(err)
		}
		err = t.Execute(dst, data)
		if err != nil {
			panic(err)
		}
	}
}

// Name Version
// FQType *semver.Version
var pipeTemplate = `
// {{.Name}}PipeWriter receives {{.FQType}}
type {{.Name}}PipeWriter interface {
	Flusher
	Write({{.FQType}}) error
}

// {{.Name}}Stream receives {{.FQType}}, writes it to the connected Pipes.
type {{.Name}}Stream struct {
	Streams []{{.Name}}PipeWriter
}

// Pipe connects a Pipe, returns the connected Pipe left-end.
func (p *{{.Name}}Stream) Pipe(s Piper) Piper {
	p.Sink(s)
	return s
}

// Sink connects an ending Piper.
func (p *{{.Name}}Stream) Sink(s Flusher) {
	// todo: add sync
	x, ok := s.({{.Name}}PipeWriter)
	if !ok {
		fmt.Printf("from %T\n", p)
		fmt.Printf("to %T\n", s)
		panic(
				fmt.Errorf("Cannot Pipe a %T on %T", s, p),
		)
	}
	p.Streams = append(p.Streams, x)
}

// Unpipe disconnect a connected Pipe.
func (p *{{.Name}}Stream) Unpipe(s Flusher) {
	// todo: add sync
	x, ok := s.({{.Name}}PipeWriter)
	if !ok {
		fmt.Printf("from %T\n", p)
		fmt.Printf("to %T\n", s)
		panic(
				fmt.Errorf("Cannot Pipe a %T on %T", s, p),
		)
	}
	i := -1
	for e, pp := range p.Streams {
		if pp == x {
			i = e
			break
		}
	}
	if i > -1 {
		p.Streams = append(p.Streams[:i], p.Streams[i+1:]...)
	}
}

// Flush flushes the connected Pipes.
func (p *{{.Name}}Stream) Flush() error {
	for _, pp := range p.Streams {
		if err := pp.Flush(); err != nil {
			return err
		}
	}
	return nil
}

// Write a {{.FQType}} on the connected Pipes.
func (p *{{.Name}}Stream) Write(d {{.FQType}}) error {
	for _, pp := range p.Streams {
		if err := pp.Write(d); err != nil {
			return err
		}
	}
	return nil
}
`

func showVer() {
	fmt.Printf("%v %v\n", "plumber", version)
}

func showHelp() {
	showVer()
	fmt.Println()
	fmt.Println("Usage")
	fmt.Println()
	fmt.Printf("	plumber [out] [pkg] [...types]\n\n")
	fmt.Printf("	out: 	Output destination of the results, use '-' for stdout.\n")
	fmt.Printf("	pkg: 	The package name of the generated code.\n")
	fmt.Printf("	types:	A list of fully qualified types such as\n")
	fmt.Printf("	     	'[]byte', 'semver.Version' or '*my.PointerType'.\n")
	fmt.Println()
}
